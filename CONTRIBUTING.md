# How to Contribute

## Quickstart

### What is git?

Follow this tutorial: https://www.atlassian.com/git/tutorials/what-is-version-control

Do you want to dive-in? There is a very nice interactive tool: https://learngitbranching.js.org/
Highly recommended.

#### Copy with git

```shell
git clone /path/to/server_project_repo
```

### Virtual Environment

Make sure you are using a distinct [venv](https://packaging.python.org/en/latest/guides/installing-using-pip-and-virtual-environments/#creating-a-virtual-environment)
at all times for each project.

And make sure, it is activated before the next steps:

```shell
source venv/bin/activate
```

**Note:** the name of the venv is assumed to be `venv`. A different name could
cause problems with the scripts (Makefile).

### Install Packages

The main dependencies are defined in `pyproject.toml`.
Full list of dependencies are pinned by pip-tools
into requirements.txt files.

We include a `Makefile`, to simplify the steps.
Now, install the project including development dependencies in editable mode:

```shell
make init
```

### Commit Your Changes

We follow standardized commit messages. To make it easy, we
use [commitizen](https://github.com/commitizen-tools/commitizen).
It should be already installed as a dev-dependency. You can use its cli interface:

```shell
cz commit
```

## Updating and managing dependencies

Use the `Makefile` at the project root for managing development environment:

### Adding/Removing Packages

Use `pyproject.toml:project.dependencies` to enter the packages you are directly using.

* Only specify the modules you are directly using.
* Do not specify upper version constraints. For example, you should write `click>=7`;
and you should not write `click>=7,<8`.
Further reading: https://iscinumpy.dev/post/bound-version-constraints/

After adjusting `pyproject.toml/project.dependencies`, run:

```shell
make update
```

With this command the sub-dependencies of main/direct dependencies will be managed automatically in `requirements.txt`.
Do not manually work on the requirements.txt files, they are autogenerated by
`pip-tools`.

## Enforce Code Quality

* [ruff](https://github.com/charliermarsh/ruff): Fast linter which combines many
of the existing linters.
See pyproject.toml for its configuration.

* [Black](https://github.com/psf/black): (Included in `ruff format`). Compliant with `PEP8`, rewrites
your code to improve overall productivity.

* [mypy](https://github.com/python/mypy): Static type checker.
[typing](https://docs.python.org/3/library/typing.html) module was introduced
in Python 3.5 and kept evolving. In my opinion, both typing and mypy reached a
mature state as of 2023. Typing is definitely nice to have
and recommended; however, it may slow down the development. Incorporate typing
as you see fit. Strongly recommended for big projects, especially for the core parts.

* We like [Google Style Guide](https://google.github.io/styleguide/pyguide.html), and follow it as close as possible
without upsetting Black.

* For [Docstrings](https://realpython.com/documenting-python-code/), **use**
[Google Style Docstring](https://google.github.io/styleguide/pyguide.html#38-comments-and-docstrings).
There is no need to repeat types in the docstrings, thanks to
[sphinx-autodoc-typehints](https://github.com/tox-dev/sphinx-autodoc-typehints).
See docs/source/conf.py for our custom documentation configuration.

They are all enforced with `pre-commit`.

### Pre-commit

We will use
[pre-commit](https://github.com/pre-commit/pre-commit) framework
to make checks every time you try to make a commit.

Pre-commit hooks are already installed during the earlier `make init` call.

Every git commit will trigger pre-commit hooks.
Optionally, you can manually trigger the hooks at anytime:
```shell
pre-commit run
```

## Testing

We use `pytest` framework.

## Git Worklow

### Workflow

We follow [GitHub Flow](https://docs.github.com/en/get-started/quickstart/github-flow).

[Github Actions](https://docs.github.com/en/actions) help us keep the `main` branch stable.

### Commit Messages

We follow [Conventional Commits 1.0.x](https://www.conventionalcommits.org/en/v1.0.0/)
for commit messages. Git hooks will run pre-commit to make sure everyone
follows it. You do not need to worry about, just keep using `commitizen`.

### Releases

We follow [Semantic Versioning 2.0.x](https://semver.org/). Keep using `commitzen`,
our well formatted commit messages will take care of versioning (and the changelog):

:exclamation: Not complete yet!

```shell
make bump
```

## A Note on pre-commit and IDE Integration

In an IDE, we want to get the hints and highlighting **real-time**
through the linters (black, ruff, mypy).
As explained we enforce the use of linters with pre-commit. Howevever,
there are two issues with precommit when it comes to IDE integration:

* pre-commit does not integrate well with IDE's, especially with VS Code
(https://github.com/microsoft/vscode-python/issues/12187). Not just IDE's,
but many tools (such as CI) want to have a local installation of the linters.

* pre-commit wants to have its own installation of the linters and does not
share any reliable information to reach them.
Since the IDE needs access to linters we have to specify them as development
dependencies as well.
This would cause us to have two versions for each linter,
resulting in multiple sources of truth.
Thus adding maintenance and possible conflicts.
(https://github.com/pre-commit/pre-commit/issues/945)


There is sadly no perfect solution.

**Our current solution is a practical one**: we do not try to match the versions between
the local installation and pre-commit. Practically, the version changes have little effect
on main features so slight version offsets should not cause any issues. The main motivation
here is to leave dev-dependencies flexible so that we avoid version conflicts with actual
dependencies. Results:
* Developer gets real-time IDE support.
* When done, the final check will be done by pre-commit.
* There is a small chance of a conflict between pre-commit and IDE linters. In those
cases, pre-commit must be followed. Developer can optionally adjust their IDE for better match.

**HINT:** Remember dev-dependencies are synced across developers via `requirements_dev.txt`.
If you notice such conflicts, you can try to alter it and set correct versions - be careful
here since it must be autogenerated by piptools.

Another possible but impractical solution is to maintain the linter
versions manually and make sure they match in the  `dev-requirements.in` and
`.pre-commit-config.yaml`. Good news is the developers should not be worried about it as
the changes to dev dependencies will be automatically updated by `cruft`.
To make it explicit and technically easy for `cruft`, we moved the
dev dependencies from `pyproject.toml/optional-dependencies` into `requirements_dev.in`.
The changes to dev tools will be done periodically by the template admin and all
projects can pull this changes via cruft.
**Note**: We have dropped support for `cruft` due to some minor but troublesome issues.
`copier` seems a more promising candidate.

An alternative solution is to use `local` repositories in the pre-commit config.
Linters will be managed locally in each project by `pyproject.toml` and
thus the exact version is given in requirements_dev.txt.
The rest of the pre-commit hooks will be managed by `.pre-commit-config.yaml`.
This way we get only one version for each tool, avoiding any conflicts.
The problem is this solution does not align well with pre-commit's intentions.
There are many proposal to overcome our problem, as an example,
one unlikely but desired
solution is to manage .pre-commit-config.yaml automatically:
https://github.com/jazzband/pip-tools/issues/1437. There is even a solution
already: https://github.com/Stephen-RA-King/piptools-sync; I do not recommend it
because its a small project with no guareentes on maintenance.
